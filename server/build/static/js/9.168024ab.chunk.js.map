{"version":3,"sources":["component/ChartContent/ChartContent.js","view/ChartPage.js"],"names":["ChartContent","props","useRef","useState","React","sort","setSort","useEffect","am4core","am4themes_material","am4themes_animated","chart","am4charts","dateFormatter","dateFormat","data","chartData","values","map","record_id","value_light","Date","parse","value_temp","value_sound","value_humidity","console","log","generatechartData","dateAxis","xAxes","push","title","text","valueAxis","yAxes","series","dataFields","valueY","dateX","strokeWidth","tooltipText","fillOpacity","range","createSeriesRange","value","limit","endValue","contents","stroke","colors","getIndex","fill","strokeOpacity","cursor","xAxis","scrollbarX","tooltip","getFillFromObject","adapter","add","x","target","tooltipDataItem","background","ToggleButtonGroup","color","exclusive","onChange","event","newAlignment","ToggleButton","id","style","minHeight","height","ChartPage","dispatch","useDispatch","sqlData","useSelector","a","chartActions","getData","length","Box","display","alignItems","justifyContent","Typography","variant"],"mappings":"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","file":"static/js/9.168024ab.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\nimport ToggleButton from \"@mui/material/ToggleButton\";\nimport ToggleButtonGroup from \"@mui/material/ToggleButtonGroup\";\nimport * as am4core from \"@amcharts/amcharts4/core\";\nimport * as am4charts from \"@amcharts/amcharts4/charts\";\nimport am4themes_animated from \"@amcharts/amcharts4/themes/animated\";\nimport am4themes_material from \"@amcharts/amcharts4/themes/material\";\n\n// interface LineChartData {\n//   d: string;\n//   v: number;\n// }\n\n// interface LineChartProps {\n//   height: number;\n//   values: LineChartData[];\n// }\n\nconst ChartContent = (props) => {\n  const divRef = useRef(null);\n  const [graphHeight, setGraphData] = useState(0);\n  const [sort, setSort] = React.useState(\"value_temp\");\n  // useEffect(() => {\n  //   const margin = { top: 20, right: 30, bottom: 30, left: 40 };\n\n  //   setGraphData(props?.height);\n\n  //   const currentElement = divRef.current;\n  //   const width = currentElement?.offsetWidth;\n  //   const height = graphHeight;\n\n  //   const documentElement = d3\n  //     .select(currentElement)\n  //     .call((g) => g.select(\"svg\").remove())\n  //     .append(\"svg\")\n  //     .attr(\"viewBox\", `0,0,${width},${height}`);\n\n  //   // const parseDate = d3.utcParse(\"%Y-%m-%dT%H:%M:%S%Z\");\n  //   // console.log(\"parseData=\", new Date(Date.parse(\"2021-09-22T14:38:13.000Z\")));\n  //   let data = {};\n  //   let d3Type = {};\n  //   let yMax = 0;\n  //   if (sort == \"value_temp\") {\n  //     data = props.values?.map(({ record_id, value_temp }) => ({\n  //       record_id: new Date(Date.parse(record_id)),\n  //       value_temp,\n  //     }));\n\n  //     d3Type = d3\n  //       .line()\n  //       .x((value) => x(value.record_id))\n  //       .y((value) => y(value.value_temp));\n  //     yMax = d3.max(data, (d) => d.value_temp);\n  //   }\n  //   if (sort == \"value_humidity\") {\n  //     data = props.values?.map(({ record_id, value_humidity }) => ({\n  //       record_id: new Date(Date.parse(record_id)),\n  //       value_humidity,\n  //     }));\n\n  //     d3Type = d3\n  //       .line()\n  //       .x((value) => x(value.record_id))\n  //       .y((value) => y(value.value_humidity));\n  //     yMax = d3.max(data, (d) => d.value_humidity);\n  //   }\n  //   if (sort == \"value_light\") {\n  //     data = props.values?.map(({ record_id, value_light }) => ({\n  //       record_id: new Date(Date.parse(record_id)),\n  //       value_light,\n  //     }));\n\n  //     d3Type = d3\n  //       .line()\n  //       .x((value) => x(value.record_id))\n  //       .y((value) => y(value.value_light));\n  //     yMax = d3.max(data, (d) => d.value_light);\n  //   }\n  //   if (sort == \"value_sound\") {\n  //     data = props.values?.map(({ record_id, value_sound }) => ({\n  //       record_id: new Date(Date.parse(record_id)),\n  //       value_sound,\n  //     }));\n\n  //     d3Type = d3\n  //       .line()\n  //       .x((value) => x(value.record_id))\n  //       .y((value) => y(value.value_sound));\n  //     yMax = d3.max(data, (d) => d.value_sound);\n  //   }\n\n  //   const xDomain = d3.extent(data, (d) => d.record_id);\n\n  //   const x = d3\n  //     .scaleUtc()\n  //     .domain(xDomain)\n  //     .range([margin.left, width - margin.right]);\n\n  //   const y = d3\n  //     .scaleLinear()\n  //     .domain([0, yMax])\n  //     .nice()\n  //     .range([height - margin.bottom, margin.top]);\n\n  //   const xAxis = (g) =>\n  //     g.attr(\"transform\", `translate(0,${height - margin.bottom})`).call(\n  //       d3\n  //         .axisBottom(x)\n  //         .ticks(width / 80)\n  //         .tickSizeOuter(0)\n  //     );\n\n  //   documentElement.append(\"g\").call(xAxis);\n\n  //   const yAxis = (g) =>\n  //     g.attr(\"transform\", `translate(${margin.left},0)`).call(d3.axisLeft(y));\n\n  //   documentElement\n  //     .append(\"g\")\n  //     .call(yAxis)\n  //     .call((g) => g.select(\".domain\").remove());\n  //   console.log(\"data==========\", data);\n  //   documentElement\n  //     .append(\"path\")\n  //     .datum(data)\n  //     .attr(\"fill\", \"none\")\n  //     .attr(\"stroke\", \"steelblue\")\n  //     .attr(\"stroke-width\", 1.5)\n  //     .attr(\"stroke-linejoin\", \"round\")\n  //     .attr(\"stroke-linecap\", \"round\")\n  //     .attr(\"d\", (data) => d3Type(data));\n\n  //   if (sort == \"value_temp\") {\n  //     documentElement\n  //       .append(\"g\")\n  //       .attr(\"transform\", \"translate(0, \" + y(props.limit[0].value) + \")\")\n  //       .append(\"line\")\n  //       .attr(\"x2\", width)\n  //       .style(\"stroke\", yMax > props.limit[0].value ? \"red\" : \"#2ecc71\")\n  //       .style(\"stroke-width\", \"2px\");\n  //   }\n  //   if (sort == \"value_humidity\") {\n  //     documentElement\n  //       .append(\"g\")\n  //       .attr(\"transform\", \"translate(0, \" + y(props.limit[1].value) + \")\")\n  //       .append(\"line\")\n  //       .attr(\"x2\", width)\n  //       .style(\"stroke\", yMax > props.limit[1].value ? \"red\" : \"#2ecc71\")\n  //       .style(\"stroke-width\", \"2px\");\n  //   }\n  //   if (sort == \"value_light\") {\n  //     documentElement\n  //       .append(\"g\")\n  //       .attr(\"transform\", \"translate(0, \" + y(props.limit[2].value) + \")\")\n  //       .append(\"line\")\n  //       .attr(\"x2\", width)\n  //       .style(\"stroke\", yMax > props.limit[2].value ? \"red\" : \"#2ecc71\")\n  //       .style(\"stroke-width\", \"2px\");\n  //   }\n  //   if (sort == \"value_sound\") {\n  //     documentElement\n  //       .append(\"g\")\n  //       .attr(\"transform\", \"translate(0, \" + y(props.limit[3].value) + \")\")\n  //       .append(\"line\")\n  //       .attr(\"x2\", width)\n  //       .style(\"stroke\", yMax > props.limit[3].value ? \"red\" : \"#2ecc71\")\n  //       .style(\"stroke-width\", \"2px\");\n  //   }\n  // }, [props.values, graphHeight, props, sort]);\n\n  useEffect(() => {\n    /* Chart code */\n    // Themes begin\n    am4core.useTheme(am4themes_material);\n    am4core.useTheme(am4themes_animated);\n    // Themes end\n\n    // Create chart instance\n    let chart = am4core.create(\"chartdiv\", am4charts.XYChart);\n\n    chart.dateFormatter.dateFormat = \"yyyy-MM-dd\";\n\n    // Add data\n    chart.data = generatechartData();\n\n    /**\n     * Use separate DateFormatter for X axis, so we can set different format\n     * (this presumes that X axis of type DateAxis was already created)\n     */\n\n    function generatechartData() {\n      let chartData = [];\n      if (sort == \"value_light\") {\n        chartData = props.values?.map(({ record_id, value_light }) => ({\n          record_id: new Date(Date.parse(record_id)),\n          value_light,\n        }));\n      }\n      if (sort == \"value_temp\") {\n        chartData = props.values?.map(({ record_id, value_temp }) => ({\n          record_id: new Date(Date.parse(record_id)),\n          value_temp,\n        }));\n      }\n      if (sort == \"value_sound\") {\n        chartData = props.values?.map(({ record_id, value_sound }) => ({\n          record_id: new Date(Date.parse(record_id)),\n          value_sound,\n        }));\n      }\n      if (sort == \"value_humidity\") {\n        chartData = props.values?.map(({ record_id, value_humidity }) => ({\n          record_id: new Date(Date.parse(record_id)),\n          value_humidity,\n        }));\n      }\n      // let firstDate = new Date();\n      // firstDate.setDate(firstDate.getDate() - 150);\n      // let visits = -40;\n      // let b = 0.6;\n      // for (var i = 0; i < 150; i++) {\n      //   // we create date objects here. In your data, you can have date strings\n      //   // and then set format of your dates using chart.dataDateFormat property,\n      //   // however when possible, use date objects, as this will speed up chart rendering.\n      //   let newDate = new Date(firstDate);\n      //   newDate.setDate(newDate.getDate() + i);\n      //   if (i > 80) {\n      //     b = 0.4;\n      //   }\n      //   visits += Math.round((Math.random() < b ? 1 : -1) * Math.random() * 10);\n\n      console.log(\"chartdata=\", chartData);\n      return chartData;\n    }\n\n    // Create axes\n    let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\n    dateAxis.dateFormatter = new am4core.DateFormatter();\n    dateAxis.title.text = \"Time\";\n    // dateAxis.startLocation = 0.5;\n    // dateAxis.endLocation = 0.5;\n\n    // Create value axis\n    let valueAxis = chart.yAxes.push(new am4charts.ValueAxis());\n    valueAxis.title.text = `${sort}`;\n\n    // Create series\n    let series = chart.series.push(new am4charts.LineSeries());\n    if (sort == \"value_temp\") {\n      series.dataFields.valueY = \"value_temp\";\n    }\n    if (sort == \"value_humidity\") {\n      series.dataFields.valueY = \"value_humidity\";\n    }\n    if (sort == \"value_light\") {\n      series.dataFields.valueY = \"value_light\";\n    }\n    if (sort == \"value_sound\") {\n      series.dataFields.valueY = \"value_sound\";\n    }\n    series.dataFields.dateX = \"record_id\";\n    series.strokeWidth = 2;\n    series.tooltipText = \"{dateX}  :  [b]{valueY.value}[/]\";\n    series.fillOpacity = 0.1;\n\n    // Create a range to change stroke for values below 0\n    let range = valueAxis.createSeriesRange(series);\n    if (sort == \"value_temp\") {\n      range.value = props.limit[0].value;\n    }\n    if (sort == \"value_humidity\") {\n      range.value = props.limit[1].value;\n    }\n    if (sort == \"value_light\") {\n      range.value = props.limit[2].value;\n    }\n    if (sort == \"value_sound\") {\n      range.value = props.limit[3].value;\n    }\n    range.endValue = -1000;\n    range.contents.stroke = chart.colors.getIndex(7);\n    range.contents.fill = range.contents.stroke;\n    range.contents.strokeOpacity = 0.9;\n    range.contents.fillOpacity = 0.1;\n\n    // Add cursor\n    chart.cursor = new am4charts.XYCursor();\n    chart.cursor.xAxis = dateAxis;\n    chart.scrollbarX = new am4core.Scrollbar();\n\n    series.tooltip.getFillFromObject = false;\n    if (sort == \"value_temp\") {\n      series.tooltip.adapter.add(\"x\", (x, target) => {\n        if (series.tooltip.tooltipDataItem.valueY < props.limit[0].value) {\n          series.tooltip.background.fill = chart.colors.getIndex(7);\n        } else {\n          series.tooltip.background.fill = chart.colors.getIndex(0);\n        }\n        return x;\n      });\n    }\n    if (sort == \"value_sound\") {\n      series.tooltip.adapter.add(\"x\", (x, target) => {\n        if (series.tooltip.tooltipDataItem.valueY < props.limit[3].value) {\n          series.tooltip.background.fill = chart.colors.getIndex(7);\n        } else {\n          series.tooltip.background.fill = chart.colors.getIndex(0);\n        }\n        return x;\n      });\n    }\n    if (sort == \"value_humidity\") {\n      series.tooltip.adapter.add(\"x\", (x, target) => {\n        if (series.tooltip.tooltipDataItem.valueY < props.limit[1].value) {\n          series.tooltip.background.fill = chart.colors.getIndex(7);\n        } else {\n          series.tooltip.background.fill = chart.colors.getIndex(0);\n        }\n        return x;\n      });\n    }\n    if (sort == \"value_light\") {\n      series.tooltip.adapter.add(\"x\", (x, target) => {\n        if (series.tooltip.tooltipDataItem.valueY < props.limit[2].value) {\n          series.tooltip.background.fill = chart.colors.getIndex(7);\n        } else {\n          series.tooltip.background.fill = chart.colors.getIndex(0);\n        }\n        return x;\n      });\n    }\n  }, [props.value, sort, props]);\n  const handleChange = (event, newAlignment) => {\n    setSort(newAlignment);\n  };\n  return (\n    <>\n      <ToggleButtonGroup\n        color=\"primary\"\n        value={sort}\n        exclusive\n        onChange={handleChange}\n      >\n        <ToggleButton value=\"value_temp\">Temperature</ToggleButton>\n        <ToggleButton value=\"value_humidity\">Humidity</ToggleButton>\n        <ToggleButton value=\"value_light\">Light</ToggleButton>\n        <ToggleButton value=\"value_sound\">Sound</ToggleButton>\n      </ToggleButtonGroup>\n      <div id=\"chartdiv\" style={{ minHeight: props.height }}></div>\n    </>\n  );\n};\n\nexport default ChartContent;\n","import { Box, Typography } from \"@mui/material\";\nimport React from \"react\";\nimport { useEffect } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport ChartContent from \"../component/ChartContent/ChartContent\";\nimport * as chartActions from \"../store/actions\";\n\nexport default function ChartPage() {\n  const dispatch = useDispatch();\n  const sqlData = useSelector(({ chart }) => chart.data);\n  const limit = useSelector(({ chart }) => chart.limit);\n  console.log(\"helloHchart page\");\n\n  useEffect(() => {\n    async function getData() {\n      dispatch(chartActions.getDatas());\n    }\n    getData();\n  }, []);\n\n  return (\n    <div>\n      {sqlData.length > 0 ? (\n        <ChartContent height={600} values={sqlData} limit={limit} />\n      ) : (\n        <Box\n          style={{\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"center\",\n            height: \"60vh\",\n          }}\n        >\n          <Typography variant=\"h4\">No data</Typography>\n        </Box>\n      )}\n    </div>\n  );\n}\n"],"sourceRoot":""}